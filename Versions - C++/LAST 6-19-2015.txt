//
//	Legal Aid Society Tools
//	Team:	Clinton Hughes
//			Nicolas Corpus
//			Khaguy Nagdimov
//			Munieshwar Ramdass
//	June 2nd, 2015 - August 14th, 2015
//

//
//	Application security has not been done
//	Simple procedures like checking for const methods or variables, or passing by references may not have been done
//	Code was written to work without regards to runtime or performance
//

#include <vector>
#include <string>
#include <iostream>
#include <fstream>
#include <sstream>
#include <cstring>
#include <cstdlib>
#include <list>
#include <algorithm>
#include <functional>
#include <limits>
#include <map>
#include <unordered_map>
#include <stack>
#include <queue>
#include <windows.h>
//#include "resource.h"
#include <iomanip>

using namespace std;


///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Information gathering
// Report generation
// File type and formating must be checked
//
//

// Parameters: string& filename
class Report {
public:
	Report(string& filename)
		: filename(filename), template_amt(100), profile_s(15), profile_1(15), profile_2(15), profile_3(15){
		bool status = read_file(filename);
		active = status;
		if (active) run();
	}

	void run(){};
	
private:
	vector < vector<float >> profile_s;
	vector < vector<float >> profile_1;
	vector < vector<float >> profile_2;
	vector < vector<float >> profile_3;
	int template_amt;
	bool active;
	string filename;
	char* context = NULL;

	bool read_file(string& name){
		ifstream ifs(name);
		if (!ifs) {
			cerr << "File has not opened successfully." << endl;
			return false;
		}

		string line;
		//getline(ifs, line); // Ignoring first line

		int counter(0);
		vector<string> tokens;

		while (getline(ifs, line)) {
			tokens.clear();
			char str[256];
			strcpy_s(str, line.c_str());
			char* pch;
			pch = strtok_s(str, ",", &context);
			while (pch) {
				tokens.push_back(pch);
				pch = strtok_s(nullptr, ",", &context);
			}
			for (int i(0); i < tokens.size(); ++i){
				if (counter == 0)
					profile_s[counter].push_back(atof(tokens[i].c_str()));
				else if (counter == 1)
					profile_1[counter].push_back(atof(tokens[i].c_str()));
				else if (counter == 2)
					profile_2[counter].push_back(atof(tokens[i].c_str()));
				else if (counter == 3)
					profile_3[counter].push_back(atof(tokens[i].c_str()));
			}
			++counter;
			if (counter > 3) counter = 0;
			delete[] pch;
		}

		ifs.close();
		return true;
	}

	friend ostream& operator<<(ostream& os, const Report& r);
};

ostream& operator<<(ostream& os, const Report& r){
	
	cout << "\nSuspect Profile:" << endl;
	for (int i(0); i < r.profile_s.size(); ++i){
		for (int j(0); j < r.profile_s[i].size(); ++j){
			cout << r.profile_s[i][j] << "\t";
		}
	}
	cout << "\nProfile 1:" << endl;
	for (int i(0); i < r.profile_1.size(); ++i){
		for (int j(0); j < r.profile_1[i].size(); ++j){
			cout << r.profile_1[i][j] << "\t";
		}
	}
	cout << "\nProfile 2:" << endl;
	for (int i(0); i < r.profile_2.size(); ++i){
		for (int j(0); j < r.profile_2[i].size(); ++j){
			cout << r.profile_2[i][j] << "\t";
		}
	}
	cout << "\nProfile 3:" << endl;
	for (int i(0); i < r.profile_3.size(); ++i){
		for (int j(0); j < r.profile_3[i].size(); ++j){
			cout << r.profile_3[i][j] << "\t";
		}
	}
	return os;
}


///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Calculations based on report
// Allele, Genotype Frequency generation
// Drop out/in analysis
//
//

double HOM_CONST = 0.03;	// inbreed constant

double PC0 = 0.96;			// Drop-in rates
double PC1 = 0.035;
double PC2 = 0.005;

double PHET0 = 0.58;		// Drop-out rates
double PHET1 = 0.4;
double PHET2 = 0.02;
double PHOM0 = 0.98;
double PHOM1 = 0.02;

class geno_f;
class person;
class rep;

// Parameters: string lotus, float length, float freq, bool flag
class allele {
public:
	allele(string lotus, float length, double freq, bool flag)
		:lotus(lotus), length(length), freq(freq), flag(flag) {}

	bool operator==(const allele& right) const {
		return (lotus == right.lotus && length == right.length && freq == right.freq && flag == right.flag);
	}
	bool operator!=(const allele& right) const {
		return !(*this == right);
	}

private:
	string lotus;
	float length;
	double freq;
	bool flag;

	friend geno_f;
	friend person;
	friend rep;
};

// Parameters: allele a, ...
class geno_f {
public:
	geno_f(allele a, ...)
		: flag(true){
		//allele input;
		va_list v;
		allele input = a;
		va_start(v, a);
		while (input.flag) {
			alleles.push_back(input);
			input = va_arg(v, allele);
		}
		va_end(v);

		cout << "\nGenotype Frequency Allele Information:" << endl;
		print_alleles();
		generate_allele_pairs();
		generate_freqs();
		cout << "\nFrequences Generated:" << endl;
		print_freqs();
	}

	void print_alleles() {
		for (int i(0); i < alleles.size(); ++i){
			cout << "\tLotus:\t\t" << alleles[i].lotus
				<< "\n\tLength:\t\t" << alleles[i].length << "\n\tFrequency:\t" << alleles[i].freq << endl;
		}
	}

	void print_freqs() {
		for (int i(0); i < freqs.size(); ++i){
			cout << "\tCombinations: " << i + 1 << " " << freqs[i] << endl;
		}
	}

	void generate_freqs() {
		for (int i(0); i < alleles.size(); ++i){
			for (int j(i); j < alleles.size(); ++j){
				if (i == j){
					freqs.push_back(calc_hom(alleles[i]));
				}
				else{
					freqs.push_back(calc_het(alleles[i], alleles[j]));
				}
			}
		}
	}

	void generate_allele_pairs() {
		for (int i(0); i < alleles.size(); ++i){
			for (int j(i); j < alleles.size(); ++j){
				allele_comb.push_back(pair<allele, allele>(alleles[i], alleles[j]));
			}
		}
	}

	double calc_hom(allele a) const {
		return a.freq * a.freq + a.freq * HOM_CONST * (1 - a.freq);
	}

	double calc_het(allele a, allele b) const {
		return 2 * a.freq * b.freq;
	}


private:
	vector<allele> alleles;
	vector<pair<allele, allele>> allele_comb;	// SORTING METHOD NEEDS TO BE DONE
	vector<double> freqs;						// SORTING METHOD NEEDS TO BE DONE
	bool flag;

	friend allele;
	friend person;
	friend rep;
};

class person {
public:
	person(string name, allele a, allele b)
		: name(name), a(a), b(b) {
		generate_freq();
		if (a == b) {
			hom = true;
			het = false;
		}
		else {
			hom = false;
			het = true;
		}
	}

	void print_alleles() {
		cout << name << "'s Alleles:" << endl;
		cout << "First Allele:" << endl;
		cout << "\tLotus:\t\t" << a.lotus
			<< "\n\tLength:\t\t" << a.length << "\n\tFrequency:\t" << a.freq << endl;
		cout << "Second Allele:" << endl;
		cout << "\tLotus:\t\t" << b.lotus
			<< "\n\tLength:\t\t" << b.length << "\n\tFrequency:\t" << b.freq << endl;
		cout << "\tFrequency:\t" << freq << endl;
	}

	void generate_freq() {
		if (a == b){
			freq = calc_hom(a);
		}
		else{
			freq = calc_het(a, b);
		}
	}

	double calc_hom(allele a) const {
		return a.freq * a.freq + a.freq * HOM_CONST * (1 - a.freq);
	}

	double calc_het(allele a, allele b) const {
		return 2 * a.freq * b.freq;
	}

	bool operator==(const person& right) const {
		return (a == right.a && b == right.b && freq == right.freq && hom == right.hom && het == right.het);
	}
	bool operator!=(const person& right) const {
		return !(*this == right);
	}

private:
	string name;
	allele a;
	allele b;
	double freq;
	bool hom;
	bool het;		// not necessary

	friend allele;
	friend geno_f;
	friend rep;
};

class rep {
public:
	rep(int unknowns, person s, geno_f g, vector<allele> a, ...)
		: flag(true), rep_num(0), unknowns(unknowns), s(s), g(g) {
		va_list v;
		vector<allele> input = a;
		va_start(v, a);
		//rep_alleles.push_back(input);
		while (input[0].flag) {
			rep_alleles.push_back(input);
			input = va_arg(v, vector<allele>);
			++rep_num;
		}
		va_end(v);

		generate_persons();
		print_persons();
		
		/*
		cout << rep_num << endl;
		for (int i(0); i < rep_alleles.size(); ++i) {
			for (int j(0); j < rep_alleles[i].size(); ++j){
				cout << rep_alleles[i][j].lotus << " " << rep_alleles[i][j].length << endl;
			}
		}
		*/
	}

	void generate_persons() {
		for (int i(0); i < g.alleles.size(); ++i){
			for (int j(i); j < g.alleles.size(); ++j) {
				persons.push_back(person("Unknown", g.alleles[i], g.alleles[j]));
			}
		}
		cout << "\npersons vector size: " << persons.size() << endl;
		cout << endl;
	}

	void print_persons() {
		cout << "\nPersons:" << endl;
		for (int i(0); i < persons.size(); ++i){
			cout << "\nName: " << persons[i].name << endl;
			persons[i].print_alleles();
		}
	}

private:
	vector<double> numerator_products;
	vector<double> denominator_products;
	double numerator_sum;
	double denominator_sum;
	double LR;

	vector<vector<allele>> rep_alleles;
	vector<person> persons;					// All possible persons for given alleles
	person s;								// Suspect profile for two alleles at a specific lotus - used for numerator
	geno_f g;
	int rep_num;
	int unknowns;
	bool flag;

	friend allele;
	friend geno_f;
	friend person;
};





///////////////////////////////////////////////////////////////////////////////////////////////////
//
// MAIN
//
//

allele NULL_ALLELE("NULL", 0.0, 0.0, false);	// Not to be confused with WILD (w) allele
												// Stops argument list

int main() {

	string filename("evidence.txt");
	Report R(filename);
	//cout << R << endl;

	// CSV Handling
	/*
	ifstream indata;
	ofstream outdata;
	outdata.open("test.csv", ios::app);
	outdata << "a1,b1,c1" << endl;
	outdata << "a2,b2,c2" << endl;
	outdata << "a2,b2,c2" << endl;
	outdata << "a2,b2,c2" << endl;
	outdata << "a2,b2,c2" << endl;
	//indata.open("test.csv");
	//string cell1;

	//indata >> cell1;

	//cout << cell1 << "\n\n";
	*/


	cout << "START LAST TESTING\n" << endl;
	allele a("D19S433", 13, 0.289, true);
	allele b("D19S433", 14, 0.341, true);
	allele w("WILD", -1, 0.37, true);

	person s("Dude from Example 20", a, b);
	s.print_alleles();

	geno_f g(a, b, w, NULL_ALLELE);

	vector<allele> rep1;
	vector<allele> rep2;
	rep1.push_back(a);
	rep1.push_back(b);
	rep2.push_back(a);
	vector <allele> rep_stop;
	rep_stop.push_back(NULL_ALLELE);
	rep(3, s, g, rep1, rep2, rep_stop);

	cout << "==========\tEND\t==========" << endl;

}