//
//	Legal Aid Society Tool
//	Team:	Clinton Hughes
//			Nicolas Corpus
//			Khaguy Nagdimov
//			Munieshwar Ramdass
//	June 2nd, 2015 - August 14th, 2015
//

//
//	Application security has not been done
//	Simple procedures like checking for const methods or variables, or passing by references may not have been done
//	Code was written to work without regards to runtime or performance
//

#include <vector>
#include <string>
#include <iostream>
#include <fstream>
#include <sstream>
#include <cstring>
#include <ctime>
#include <cstdlib>
#include <list>
#include <algorithm>
#include <iterator>
#include <functional>
#include <limits>
#include <map>
#include <unordered_map>
#include <stack>
#include <queue>
#include <cassert>
#include <windows.h>
//#include "resource.h"
#include <stdlib.h>
#include <iomanip>
#include <stdio.h>
#include <math.h>
#include <stdarg.h>

typedef std::string String;
typedef std::vector<String> CSVRow;
typedef CSVRow::const_iterator CSVRowCI;
typedef std::vector<CSVRow> CSVDatabase;
typedef CSVDatabase::const_iterator CSVDatabaseCI;

using namespace std;

class timer {
public:
	timer() : start(clock()) {}
	double elapsed() { return (clock() - start) / CLOCKS_PER_SEC; }
	void reset() { start = clock(); }
private:
	double start;
};


///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Calculations based on report
// Allele, Genotype Frequency generation
// Drop out/in analysis
//
//

//char* CONTEXT = NULL;
double HOM_CONST = 0.03;	// inbreed constant

double PC0 = 0.96;			// Drop-in rates
double PC1 = 0.035;
double PC2 = 0.005;

double PHET0 = 0.58;		// Drop-out rates
double PHET1 = 0.4;			// Not constant
double PHET2 = 0.02;
double PHOM0 = 0.98;
double PHOM1 = 0.02;

class geno_f;
class person;
class rep;

// Parameters: string lotus, double length, double freq, bool flag
class allele {
public:
	allele(string lotus, double length, double freq, bool flag)
		:lotus(lotus), length(length), freq(freq), flag(flag) {}

	bool operator==(const allele& right) const {
		return (lotus == right.lotus && length == right.length && freq == right.freq && flag == right.flag);
	}

	bool operator!=(const allele& right) const {
		return !(*this == right);
	}

	string get_lotus() const { return lotus; }

	double get_length() const { return length; }

	double get_freq() const { return freq; }

	bool get_flag() const { return flag; }

private:
	string lotus;
	double length;
	double freq;
	bool flag;

	friend geno_f;
	friend person;
	friend rep;
};

// Parameter: vector<allele>& a
class geno_f {
public:
	geno_f(vector<allele>& a)
		: flag(true){

		for (int i(0); i < a.size(); ++i) {
			alleles.push_back(a[i]);
		}

		generate_allele_pairs();
		generate_freqs();
	}

	void print_alleles() {
		for (int i(0); i < alleles.size(); ++i){
			cout << "\tLotus:\t\t" << alleles[i].lotus
				<< "\n\tLength:\t\t" << alleles[i].length << "\n\tFrequency:\t" << alleles[i].freq << endl;
		}
	}

	void print_freqs() {
		for (int i(0); i < freqs.size(); ++i){
			cout << "\tCombinations: " << i + 1 << " " << freqs[i] << endl;
		}
	}

	void generate_freqs() {
		for (int i(0); i < alleles.size(); ++i){
			for (int j(i); j < alleles.size(); ++j){
				if (i == j){
					freqs.push_back(calc_hom(alleles[i]));
				}
				else{
					freqs.push_back(calc_het(alleles[i], alleles[j]));
				}
			}
		}
	}

	void generate_allele_pairs() {
		for (int i(0); i < alleles.size(); ++i){
			for (int j(i); j < alleles.size(); ++j){
				allele_comb.push_back(pair<allele, allele>(alleles[i], alleles[j]));
			}
		}
	}

	double calc_hom(allele a) const {
		return a.freq * a.freq + a.freq * HOM_CONST * (1 - a.freq);
	}

	double calc_het(allele a, allele b) const {
		return 2 * a.freq * b.freq;
	}


private:
	vector<allele> alleles;
	vector<pair<allele, allele>> allele_comb;
	vector<double> freqs;
	bool flag;

	friend allele;
	friend person;
	friend rep;
};

// Parameters: string name, allele a, allele b
class person {
public:
	person(string name, allele a, allele b)
		: name(name), a(a), b(b) {
		generate_freq();
		if (a == b) {
			hom = true;
			het = false;
		}
		else {
			hom = false;
			het = true;
		}
	}

	void print_alleles() {
		cout << name << "'s Alleles:" << endl;
		cout << "First Allele:" << endl;
		cout << "\tLotus:\t\t\t" << a.lotus
			<< "\n\tLength:\t\t\t" << a.length << "\n\tFrequency:\t\t" << a.freq << endl;
		cout << "Second Allele:" << endl;
		cout << "\tLotus:\t\t\t" << b.lotus
			<< "\n\tLength:\t\t\t" << b.length << "\n\tFrequency:\t\t" << b.freq << endl;
		cout << "\tGenotype Frequency:\t" << freq << endl;
	}

	void generate_freq() {
		if (a == b){
			freq = calc_hom(a);
		}
		else{
			freq = calc_het(a, b);
		}
	}

	double calc_hom(allele a) const {
		return a.freq * a.freq + a.freq * HOM_CONST * (1 - a.freq);
	}

	double calc_het(allele a, allele b) const {
		return 2 * a.freq * b.freq;
	}

	bool operator==(const person& right) const {
		return (a == right.a && b == right.b && freq == right.freq && hom == right.hom && het == right.het);
	}
	bool operator!=(const person& right) const {
		return !(*this == right);
	}

	string get_name() { return name; }

private:
	string name;
	allele a;
	allele b;
	double freq;
	bool hom;
	bool het;

	friend allele;
	friend geno_f;
	friend rep;
};

// Parameters: int unknowns, person s, geno_f g, vector<vector<allele>>& a
class rep {
public:
	rep(int unknowns, person s, geno_f g, vector<vector<allele>>& a)
		: flag(true), rep_num(0), s(s), g(g), unknowns(unknowns) {

		for (int i(0); i < unknowns; ++i) {
			vector<person> p;
			population.push_back(p);
		}

		for (int i(0); i < a.size(); ++i) {
			rep_alleles.push_back(a[i]);
			++rep_num;
		}

		vector<int> tmp;
		for (int i(0); i < g.allele_comb.size(); ++i) {
			tmp.push_back(i);
		}
		permute_vector_driver(tmp, unknowns);

		generate_population();
		for (int i(0); i < population[0].size(); ++i) {
			vector<person> p;
			population_t.push_back(p);
		}
		transpose(population, population_t);
		generate_numerator_sum();
		cout << "Numerator:\t\t" << numerator_sum << endl;
		generate_denominator_sum();
		cout << "Denominator:\t\t" << denominator_sum << endl;
		LR = numerator_sum / denominator_sum;
		cout << "Likelihood Ratio:\t" << LR << endl;

	}

	void permute_vector(const vector<int>& elems, unsigned long req_len, vector<unsigned long>& pos, unsigned long depth, unsigned long margin) {
		if (depth >= req_len) {
			vector<int> index_vector;

			for (unsigned long ii = 0; ii < pos.size(); ++ii) {
				index_vector.push_back(elems[pos[ii]]);
			}
			indicies.push_back(index_vector);
			return;
		}

		for (unsigned long ii = 0; ii < elems.size(); ++ii) { // CHANGE ii TO margin TO MAKE THIS A COMBINATION WITH REPETITION
			pos[depth] = ii;
			permute_vector(elems, req_len, pos, depth + 1, ii);
		}
		return;
	}

	void permute_vector_driver(const vector<int>& elems, unsigned long req_len) {
		assert(req_len > 0 && req_len <= elems.size());
		vector<unsigned long> positions(req_len, 0);
		permute_vector(elems, req_len, positions, 0, 0);
	}

	void generate_population(){
		for (int i(0); i < indicies.size(); ++i){
			for (int j(0); j < indicies[i].size(); ++j){
				person temp("Unknown", g.allele_comb[indicies[i][j]].first, g.allele_comb[indicies[i][j]].second);
				population[j].push_back(temp);

			}
		}
	}

	void generate_denominator_sum() {
		double sum(0.0);
		double prod(1.0);
		for (int i(0); i < population_t.size(); ++i){
			for (int j(0); j < population_t[i].size(); ++j){
				prod *= population_t[i][j].freq;
			}
			for (int j(0); j < population_t[i].size(); ++j){
				for (int k(0); k < rep_alleles.size(); ++k){
					prod *= drop_out(population_t[i][j], rep_alleles[k]);
				}
			}
			for (int j(0); j < rep_alleles.size(); ++j){
				prod *= drop_in(population_t[i], rep_alleles[j]);
			}
			sum += prod;
			prod = 1.0;
		}
		denominator_sum = sum;
	}

	void generate_numerator_sum() {
		double sum(0.0);
		double prod(1.0);
		for (int i(0); i < population_t.size(); ++i){
			if (population_t[i][0] == s) {
				for (int j(1); j < population_t[i].size(); ++j){
					prod *= population_t[i][j].freq;
				}
				for (int j(0); j < population_t[i].size(); ++j){
					for (int k(0); k < rep_alleles.size(); ++k){
						prod *= drop_out(population_t[i][j], rep_alleles[k]);
					}
				}
				for (int j(0); j < rep_alleles.size(); ++j){
					prod *= drop_in(population_t[i], rep_alleles[j]);
				}
				sum += prod;
				prod = 1.0;
			}
		}
		numerator_sum = sum;
	}

	double drop_out(person p, vector<allele>& v) {
		if (p.hom) {
			for (int i(0); i < v.size(); ++i) {
				if (p.a == v[i] && p.b == v[i])
					return PHOM0;
			}
			return PHOM1;
		}
		else if (p.het) {
			bool present_first = false;
			bool present_second = false;
			for (int i(0); i < v.size(); ++i) {
				if (p.a == v[i])
					present_first = true;
				if (p.b == v[i])
					present_second = true;
			}
			if (present_first && present_second)
				return PHET0;
			else if (!present_first && !present_second)
				return PHET2;
			else if ((present_first && !present_second) || (!present_first && present_second))
				return PHET1;
		}
	}

	double drop_in(vector<person>& p, vector<allele>& a) {
		vector<allele> tmp;
		for (int i(0); i < p.size(); ++i) {
			tmp.push_back(p[i].a);
			tmp.push_back(p[i].b);
		}
		tmp.erase(unique(begin(tmp), end(tmp)), end(tmp));
		int c(0);

		for (int i(0); i < a.size(); ++i)
		if (find(tmp.begin(), tmp.end(), a[i]) == tmp.end())
			++c;

		if (c == 0)
			return PC0;
		else if (c == 1)
			return PC1;
		else
			return PC2;
	}

	void transpose(vector<vector<person>>& a, vector<vector<person>>& b) {
		for (int i = 0; i < a.size(); ++i) {
			for (int j = 0; j < a[i].size(); ++j) {
				b[j].push_back(a[i][j]);
			}
			vector<person>().swap(a[i]);
		}
		vector<vector<person>>().swap(a);
	}

	person get_suspect() { return s; }

	int get_unknowns() { return unknowns; }

	double get_LR() { return LR; }

private:
	double numerator_sum;
	double denominator_sum;
	double LR;

	vector<vector<allele>> rep_alleles;
	vector<vector<person>> population;		// Population accounted for in the demominator
	vector<vector<person>> population_t;
	vector<vector<int>> indicies;

	person s;								// Suspect profile for two alleles at a specific lotus - used for numerator
	geno_f g;
	int rep_num;
	int unknowns;
	bool flag;

	friend allele;
	friend geno_f;
	friend person;
};

double generate_wild_allele_freq(vector<allele>& alleles) {
	double c(1.0);
	for (int i(0); i < alleles.size(); ++i) {
		c -= alleles[i].get_freq();
	}
	return c;
}

double get_input_freq(CSVDatabase& db, string& lotus, double length, char race) {
	for (int i(0); i < db.size(); ++i) {
		for (int j(0); j < db[i].size(); ++j) {
			if (db[i][j] == lotus && atof(db[i][j + 1].c_str()) == length && race == 'b')
				return atof(db[i][j + 2].c_str());
			else if (db[i][j] == lotus && atof(db[i][j + 1].c_str()) == length && race == 'c')
				return atof(db[i][j + 3].c_str());
			else if (db[i][j] == lotus && atof(db[i][j + 1].c_str()) == length && race == 'h')
				return atof(db[i][j + 4].c_str());
			else if (db[i][j] == lotus && atof(db[i][j + 1].c_str()) == length && race == 'a')
				return atof(db[i][j + 5].c_str());
		}
	}
	cout << "Frequency not found - LR given will most likely be wrong!" << endl;
	return 0.0;
}

string get_input_freq_string(CSVDatabase& db, string lotus, string length, char race) {
	for (int i(0); i < db.size(); ++i) {
		for (int j(0); j < db[i].size(); ++j) {
			if (db[i][j] == lotus && db[i][j+1] == length && race == 'b')
				return db[i][j + 2];
			else if (db[i][j] == lotus && db[i][j+1] == length && race == 'c')
				return db[i][j + 3];
			else if (db[i][j] == lotus && db[i][j+1] == length && race == 'h')
				return db[i][j + 4];
			else if (db[i][j] == lotus && db[i][j+1] == length && race == 'a')
				return db[i][j + 5];
		}
	}
	string str = "0.0";
	return str;
}

double read_csv(CSVDatabase& db, string db_name) {
	ifstream ifs(db_name);
	String csvLine;
	while (getline(ifs, csvLine)){
		istringstream csvStream(csvLine);
		CSVRow csvRow;
		String csvCol;
		while (getline(csvStream, csvCol, ','))
			csvRow.push_back(csvCol);
		db.push_back(csvRow);
	}
	ifs.close();
	return true;
}

person get_data(CSVDatabase& db, CSVDatabase& adb, vector<vector<allele>>& a, vector<allele>& b, int& c, int& q, char race) {
	string lotus;
	string name("Suspect");
	vector<allele> s_tmp;
	vector<allele> r_tmp;
	for (int i(0); i < db[0].size(); ++i) {
		if (db[0][i] == "Suspect Name")
			name = db[1][i];
		else if (db[0][i] == "Lotus")
			lotus = db[1][i];
		else if (db[0][i] == "Contributors")
			c = atof(db[1][i].c_str());
		else if (db[0][i] == "Quant")
			q = atof(db[1][i].c_str());
		else if (db[0][i] == "Alleles") {
			istringstream csvCell(db[1][i]);
			string sub_cell;
			while (getline(csvCell, sub_cell, ';')) {
				allele tmp_a(lotus, atof(sub_cell.c_str()), get_input_freq(adb, lotus, atof(sub_cell.c_str()), race), true);
				b.push_back(tmp_a);
			}
		}
		else if (db[0][i] == "Suspect Alleles") {
			istringstream csvCell(db[1][i]);
			string sub_cell;
			while (getline(csvCell, sub_cell, ';')) {
				allele tmp_a(lotus, atof(sub_cell.c_str()), get_input_freq(adb, lotus, atof(sub_cell.c_str()), race), true);
				s_tmp.push_back(tmp_a);
			}
		}
		else if (db[0][i] == "HOM0") {
			PHOM0 = atof(db[1][i].c_str());
			double full(1.0);
			PHOM1 = full - PHOM0;
		}
		else if (db[0][i] == "HET0") {
			PHET0 = atof(db[1][i].c_str());
			double full(1.0);
			PHET1 = full - (PHET2 + PHET0);
		}
		else if (db[0][i] == "REP") {
			istringstream csvCell(db[1][i]);
			string sub_cell;
			while (getline(csvCell, sub_cell, ';')) {
				allele tmp_a(lotus, atof(sub_cell.c_str()), get_input_freq(adb, lotus, atof(sub_cell.c_str()), race), true);
				r_tmp.push_back(tmp_a);
			}
			a.push_back(r_tmp);
			r_tmp.clear();
		}
	}
	double freq = generate_wild_allele_freq(b);
	allele wild(lotus + "-W", -1, freq, true);
	b.push_back(wild);
	return person(name, s_tmp[0], s_tmp[1]);
}

vector<string> run_LAST(vector<vector<string>>& allele_database, int e, char race) {
	timer time;
	double nuClicks;

	vector<vector<string>> evidence_database;

	read_csv(evidence_database, "Evidence_" + to_string(e) + ".csv");

	vector<vector<allele>> replicates;
	vector<allele> alleles;
	int contributors(2);
	int quant(75);
	person suspect = get_data(evidence_database, allele_database, replicates, alleles, contributors, quant, race);

	geno_f genotypes(alleles);
	rep report(contributors, suspect, genotypes, replicates);

	vector<string> info;
	info.push_back(suspect.get_name());
	info.push_back(alleles[0].get_lotus());
	info.push_back(to_string(report.get_LR()));

	nuClicks = time.elapsed();

	info.push_back(to_string(nuClicks));

	return info;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//
// MAIN
//
//

allele NULL_ALLELE("NULL", 0.0, 0.0, false);	// Not to be confused with WILD (w) allele
// Stops argument list

int main() {
	cout << "///////////////////////////////////////////////////////" << endl;
	cout << "//" << endl;
	cout << "//\tWELCOME TO LEGAL AID STATISTICAL TOOL" << endl;
	cout << "//" << endl;
	cout << "//" << endl;
	cout << "\n________________________________________________\n" << endl;
	timer time;
	ofstream ofs("output.txt");
	double nuClicks(0.0);

	vector<vector<string>> allele_database(6);
	read_csv(allele_database, "Allele_Frequencies.csv");
	int c(1);
	time.reset();
	while (true) {
		ifstream ifs("Evidence_" + to_string(c) + ".csv");
		if (ifs) {
			cout << "\nRunning Analysis for Black" << endl;
			ofs << "\nAnalysis for Black" << endl;
			vector<string> vb = run_LAST(allele_database, c, 'b');
			ofs << "\tSuspect:\t\t" << vb[0] << endl;
			ofs << "\tLotus:\t\t\t" << vb[1] << endl;
			ofs << "\tLikelihood Ratio:\t" << vb[2] << endl;
			ofs << "\tRuntime:\t\t" << vb[3] << endl;
			vb.clear();
			
			cout << "\nRunning Analysis for Caucasian" << endl;
			ofs << "\nAnalysis for Caucasian" << endl;
			vector<string> vc = run_LAST(allele_database, c, 'c');
			ofs << "\tSuspect:\t\t" << vc[0] << endl;
			ofs << "\tLotus:\t\t\t" << vc[1] << endl;
			ofs << "\tLikelihood Ratio:\t" << vc[2] << endl;
			ofs << "\tRuntime:\t\t" << vc[3] << endl;
			vc.clear();
			
			cout << "\nRunning Analysis for Hispanic" << endl;
			ofs << "\nAnalysis for Hispanic" << endl;
			vector<string> vh = run_LAST(allele_database, c, 'h');
			ofs << "\tSuspect:\t\t" << vh[0] << endl;
			ofs << "\tLotus:\t\t\t" << vh[1] << endl;
			ofs << "\tLikelihood Ratio:\t" << vh[2] << endl;
			ofs << "\tRuntime:\t\t" << vh[3] << endl;
			vh.clear();
			
			cout << "\nRunning Analysis for Asian" << endl;
			ofs << "\nAnalysis for Asian" << endl;
			vector<string> va = run_LAST(allele_database, c, 'a');
			ofs << "\tSuspect:\t\t" << va[0] << endl;
			ofs << "\tLotus:\t\t\t" << va[1] << endl;
			ofs << "\tLikelihood Ratio:\t" << va[2] << endl;
			ofs << "\tRuntime:\t\t" << va[3] << endl;
			va.clear();
		}
		ofs << "\n_____________________________________________________________\n" << endl;
		cout << "\n________________________________________________\n" << endl;
		++c;
		if (c == 16) { break; }
	}

	nuClicks = time.elapsed();
	cout << "\n\tTime to run:\t" << nuClicks << " second(s)" << endl;
	cout << "\n\t\tLAST Analysis Finished!\n" << endl;
	ofs.close();

}