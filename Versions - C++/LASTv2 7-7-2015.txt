//
//	Legal Aid Society Tool
//	Team:	Clinton Hughes
//			Nicolas Corpus
//			Khaguy Nagdimov
//			Munieshwar Ramdass
//	June 2nd, 2015 - August 14th, 2015
//

//
//	Application security has not been done
//	Simple procedures like checking for const methods or variables, or passing by references may not have been done
//	Code was written to work without regards to runtime or performance
//

#include <vector>
#include <string>
#include <iostream>
#include <fstream>
#include <sstream>
#include <cstring>
#include <ctime>
#include <chrono>
#include <cstdlib>
#include <list>
#include <algorithm>
#include <iterator>
#include <functional>
#include <limits>
#include <map>
#include <unordered_map>
#include <stack>
#include <queue>
#include <cassert>
#include <windows.h>
//#include "resource.h"
#include <stdlib.h>
#include <iomanip>
#include <stdio.h>
#include <math.h>
#include <stdarg.h>

typedef std::string String;
typedef std::vector<String> CSVRow;
typedef CSVRow::const_iterator CSVRowCI;
typedef std::vector<CSVRow> CSVDatabase;
typedef CSVDatabase::const_iterator CSVDatabaseCI;

using namespace std;

class timer {
public:
	timer() : start(clock()) {}
	double elapsed() { return (clock() - start) / CLOCKS_PER_SEC; }
	void reset() { start = clock(); }
private:
	double start;
};


///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Calculations based on report
// Allele, Genotype Frequency generation
// Drop out/in analysis
//
//

//char* CONTEXT = NULL;
int FILE_NUM = 1;
int RACE = 1;
const double HOM_CONST = 0.03;	// inbreed constant

double PC0 = 0.96;			// Drop-in rates
double PC1 = 0.035;			// Not constant
double PC2 = 0.005;			// Initialized to low copy values

double PHET0 = 0.58;		// Drop-out rates
double PHET1 = 0.4;			// Not constant
double PHET2 = 0.02;
double PHOM0 = 0.98;
double PHOM1 = 0.02;

bool DEDUCIBLE = false;

class geno_f;
class person;
class rep;

// Parameters: string locus, double length, double freq, bool flag
class allele {
public:
	allele(string locus, double length, double freq, bool flag)
		:locus(locus), length(length), freq(freq), flag(flag) {}

	bool operator==(const allele& right) const {
		return (locus == right.locus && length == right.length && freq == right.freq && flag == right.flag);
	}

	bool operator!=(const allele& right) const {
		return !(*this == right);
	}

	string get_locus() const { return locus; }

	double get_length() const { return length; }

	double get_freq() const { return freq; }

	bool get_flag() const { return flag; }

private:
	string locus;
	double length;
	double freq;
	bool flag;

	friend geno_f;
	friend person;
	friend rep;
};

// Parameter: vector<allele>& a
class geno_f {
public:
	geno_f(vector<allele>& a)
		: flag(true){

		for (int i(0); i < a.size(); ++i) {
			alleles.push_back(a[i]);
		}

		generate_allele_pairs();
		generate_freqs();
	}

	void print_alleles() {
		for (int i(0); i < alleles.size(); ++i){
			cout << "\tlocus:\t\t" << alleles[i].locus
				<< "\n\tLength:\t\t" << alleles[i].length << "\n\tFrequency:\t" << alleles[i].freq << endl;
		}
	}

	void print_freqs() {
		for (int i(0); i < freqs.size(); ++i){
			cout << "\tCombinations: " << i + 1 << " " << freqs[i] << endl;
		}
	}

	void generate_freqs() {
		for (int i(0); i < alleles.size(); ++i){
			for (int j(i); j < alleles.size(); ++j){
				if (i == j){
					freqs.push_back(calc_hom(alleles[i]));
				}
				else{
					freqs.push_back(calc_het(alleles[i], alleles[j]));
				}
			}
		}
	}

	void generate_allele_pairs() {
		for (int i(0); i < alleles.size(); ++i){
			for (int j(i); j < alleles.size(); ++j){
				allele_comb.push_back(pair<allele, allele>(alleles[i], alleles[j]));
			}
		}
	}

	double calc_hom(allele a) const {
		return a.freq * a.freq + a.freq * HOM_CONST * (1 - a.freq);
	}

	double calc_het(allele a, allele b) const {
		return 2 * a.freq * b.freq;
	}


private:
	vector<allele> alleles;
	vector<pair<allele, allele>> allele_comb;
	vector<double> freqs;
	bool flag;

	friend allele;
	friend person;
	friend rep;
};

// Parameters: string name, allele a, allele b
class person {
public:
	person(string name, allele a, allele b)
		: name(name), a(a), b(b) {
		generate_freq();
		if (a == b) {
			hom = true;
			het = false;
		}
		else {
			hom = false;
			het = true;
		}
	}

	void print_alleles() {
		cout << name << "'s Alleles:" << endl;
		cout << "First Allele:" << endl;
		cout << "\tlocus:\t\t\t" << a.locus
			<< "\n\tLength:\t\t\t" << a.length << "\n\tFrequency:\t\t" << a.freq << endl;
		cout << "Second Allele:" << endl;
		cout << "\tlocus:\t\t\t" << b.locus
			<< "\n\tLength:\t\t\t" << b.length << "\n\tFrequency:\t\t" << b.freq << endl;
		cout << "\tGenotype Frequency:\t" << freq << endl;
	}

	void generate_freq() {
		if (a == b){
			freq = calc_hom(a);
		}
		else{
			freq = calc_het(a, b);
		}
	}

	double calc_hom(allele a) const {
		return a.freq * a.freq + a.freq * HOM_CONST * (1 - a.freq);
	}

	double calc_het(allele a, allele b) const {
		return 2 * a.freq * b.freq;
	}

	bool operator==(const person& right) const {
		return (a == right.a && b == right.b && freq == right.freq && hom == right.hom && het == right.het);
	}
	bool operator!=(const person& right) const {
		return !(*this == right);
	}

	string get_name() { return name; }

	allele get_a() { return a; }

	allele get_b() { return b; }

private:
	string name;
	allele a;
	allele b;
	double freq;
	bool hom;
	bool het;

	friend allele;
	friend geno_f;
	friend rep;
};

// Parameters: int unknowns, person s, geno_f g, vector<vector<allele>>& a
class rep {
public:
	rep(int unknowns, person s, geno_f g, vector<vector<allele>>& a)
		: flag(true), rep_num(0), s(s), g(g), unknowns(unknowns) {

		for (int i(0); i < unknowns; ++i) {
			vector<person> p;
			population.push_back(p);
		}

		for (int i(0); i < a.size(); ++i) {
			rep_alleles.push_back(a[i]);
			++rep_num;
		}

		vector<int> tmp;
		for (int i(0); i < g.allele_comb.size(); ++i) {
			tmp.push_back(i);
		}
		permute_vector_driver(tmp, unknowns);
		generate_persons();
		generate_population();
		for (int i(0); i < population[0].size(); ++i) {
			vector<person> p;
			population_t.push_back(p);
		}
		transpose(population, population_t);

		check_person();

		cout << "\nNow Generating Sums..." << endl;
		generate_sums();
		//generate_denominator_sum();
		//cout << "Denominator:\t\t" << denominator_sum << endl;
		//generate_numerator_sum();
		//cout << "Numerator:\t\t" << numerator_sum << endl;

		ofstream ofs;
		ofs.open("Evidence_" + to_string(FILE_NUM) + ".csv", ios::app);
		//assert(!ofs.fail());

		LR = numerator_sum / denominator_sum;
		cout << "Likelihood Ratio:\t" << LR << endl;
		if (RACE == 1) {
			ofs << "\nBLACK,";
		}
		else if (RACE == 2) {
			ofs << "\nCAUCASIAN,";
		}
		else if (RACE == 3) {
			ofs << "\nHISPANIC,";
		}
		else if (RACE == 4) {
			ofs << "\nASIAN,";
		}
		ofs << "Likelihood Ratio:," << LR << endl;

		for (int i(0); i < persons.size() && i < LRs.size(); ++i) {
			cout << persons[i].a.length << "\t" << persons[i].b.length << "\t" << LRs[i] << endl;
			ofs << persons[i].a.length << "," << persons[i].b.length << "," << LRs[i] << endl;
		}

		ofs.close();
		//assert(!ofs.fail());
	}

	void permute_vector(const vector<int>& elems, unsigned long req_len, vector<unsigned long>& pos, unsigned long depth, unsigned long margin) {
		if (depth >= req_len) {
			vector<int> index_vector;

			for (unsigned long ii = 0; ii < pos.size(); ++ii) {
				index_vector.push_back(elems[pos[ii]]);
			}
			indicies.push_back(index_vector);
			return;
		}

		for (unsigned long ii = 0; ii < elems.size(); ++ii) { // CHANGE ii TO margin TO MAKE THIS A COMBINATION WITH REPETITION
			pos[depth] = ii;
			permute_vector(elems, req_len, pos, depth + 1, ii);
		}
		return;
	}

	void permute_vector_driver(const vector<int>& elems, unsigned long req_len) {
		assert(req_len > 0 && req_len <= elems.size());
		vector<unsigned long> positions(req_len, 0);
		permute_vector(elems, req_len, positions, 0, 0);
	}

	void generate_population(){
		for (int i(0); i < indicies.size(); ++i){
			for (int j(0); j < indicies[i].size(); ++j){
				person temp("Unknown", g.allele_comb[indicies[i][j]].first, g.allele_comb[indicies[i][j]].second);
				population[j].push_back(temp);

			}
		}
	}

	void generate_sums() {
		double sum(0.0);
		double prod(1.0);
		double s_sum(0.0);
		double s_prod(1.0);

		double sum_d(0.0);
		double prod_d(1.0);

		for (int ii(0); ii < persons.size(); ++ii) {
			for (int i(0); i < population_t.size(); ++i){
				if (population_t[i][0] == persons[ii] && population_t[i][0] == s) {
					for (int j(0); j < population_t[i].size(); ++j){
						if (j != 0) {
							prod *= population_t[i][j].freq;
							s_prod = prod;
						}
						prod_d *= population_t[i][j].freq;
					}
					for (int j(0); j < population_t[i].size(); ++j){
						for (int k(0); k < rep_alleles.size(); ++k){
							prod *= drop_out(population_t[i][j], rep_alleles[k]);
							s_prod = prod;
							prod_d *= drop_out(population_t[i][j], rep_alleles[k]);
						}
					}
					for (int j(0); j < rep_alleles.size(); ++j){
						prod *= drop_in(population_t[i], rep_alleles[j]);
						s_prod = prod;
						prod_d *= drop_in(population_t[i], rep_alleles[j]);
					}
					sum += prod;
					sum_d += prod_d;
					prod = 1.0;
					prod_d = 1.0;

					s_sum += s_prod;
					s_prod = 1.0;
				}
				else if (population_t[i][0] == persons[ii]) {
					for (int j(0); j < population_t[i].size(); ++j){
						if (j != 0) {
							prod *= population_t[i][j].freq;
						}
						prod_d *= population_t[i][j].freq;
					}
					for (int j(0); j < population_t[i].size(); ++j){
						for (int k(0); k < rep_alleles.size(); ++k){
							prod *= drop_out(population_t[i][j], rep_alleles[k]);
							prod_d *= drop_out(population_t[i][j], rep_alleles[k]);
						}
					}
					for (int j(0); j < rep_alleles.size(); ++j){
						prod *= drop_in(population_t[i], rep_alleles[j]);
						prod_d *= drop_in(population_t[i], rep_alleles[j]);
					}
					sum += prod;
					sum_d += prod_d;
					prod = 1.0;
					prod_d = 1.0;
				}
			}
			cout << ".";
			numerators.push_back(sum);
			sum = 0.0;
		}
		cout << endl;
		numerator_sum = s_sum;
		denominator_sum = sum_d;
		for (int i(0); i < numerators.size(); ++i) {
			LRs.push_back(numerators[i] / denominator_sum);
		}
	}

	/*void generate_denominator_sum() {
		ofstream ofs;
		ofs.open("Evidence_" + to_string(FILE_NUM) + ".csv", ios::app);
		ofs << endl;

		double sum(0.0);
		double prod(1.0);
		for (int i(0); i < population_t.size(); ++i){
			for (int j(0); j < population_t[i].size(); ++j){
				prod *= population_t[i][j].freq;
				ofs << prod << ",";
			}
			for (int j(0); j < population_t[i].size(); ++j){
				for (int k(0); k < rep_alleles.size(); ++k){
					prod *= drop_out(population_t[i][j], rep_alleles[k]);
					ofs << prod << ",";
				}
			}
			for (int j(0); j < rep_alleles.size(); ++j){
				prod *= drop_in(population_t[i], rep_alleles[j]);
				ofs << prod << ",";
			}
			sum += prod;
			prod = 1.0;
			ofs << ",Sum:," << sum << endl;
		}
		denominator_sum = sum;
		ofs << endl;

		ofs.close();
	}

	void generate_numerator_sum() {
		double sum(0.0);
		double prod(1.0);
		double s_sum(0.0);
		double s_prod(1.0);
		for (int ii(0); ii < persons.size(); ++ii) {
			for (int i(0); i < population_t.size(); ++i){
				if (population_t[i][0] == persons[ii] && population_t[i][0] == s) {
					for (int j(1); j < population_t[i].size(); ++j){
						prod *= population_t[i][j].freq;
						s_prod = prod;
					}
					for (int j(0); j < population_t[i].size(); ++j){
						for (int k(0); k < rep_alleles.size(); ++k){
							prod *= drop_out(population_t[i][j], rep_alleles[k]);
							s_prod = prod;
						}
					}
					for (int j(0); j < rep_alleles.size(); ++j){
						prod *= drop_in(population_t[i], rep_alleles[j]);
						s_prod = prod;
					}
					sum += prod;
					prod = 1.0;

					s_sum += s_prod;
					s_prod = 1.0;
				}
				else if (population_t[i][0] == persons[ii]) {
					for (int j(1); j < population_t[i].size(); ++j){
						prod *= population_t[i][j].freq;
					}
					for (int j(0); j < population_t[i].size(); ++j){
						for (int k(0); k < rep_alleles.size(); ++k){
							prod *= drop_out(population_t[i][j], rep_alleles[k]);
						}
					}
					for (int j(0); j < rep_alleles.size(); ++j){
						prod *= drop_in(population_t[i], rep_alleles[j]);
					}
					sum += prod;
					prod = 1.0;
				}
			}
			LRs.push_back(sum / denominator_sum);
			sum = 0.0;
		}
		numerator_sum = s_sum;
	}*/

	double drop_out(person p, vector<allele>& v) {
		if (p.hom) {
			for (int i(0); i < v.size(); ++i) {
				if (p.a == v[i] && p.b == v[i])
					return PHOM0;
			}
			return PHOM1;
		}
		else if (p.het) {
			bool present_first = false;
			bool present_second = false;
			for (int i(0); i < v.size(); ++i) {
				if (p.a == v[i])
					present_first = true;
				if (p.b == v[i])
					present_second = true;
			}
			if (present_first && present_second)
				return PHET0;
			else if (!present_first && !present_second)
				return PHET2;
			else if ((present_first && !present_second) || (!present_first && present_second))
				return PHET1;
		}
	}

	double drop_in(vector<person>& p, vector<allele>& a) {
		vector<allele> tmp;
		for (int i(0); i < p.size(); ++i) {
			tmp.push_back(p[i].a);
			tmp.push_back(p[i].b);
		}
		tmp.erase(unique(begin(tmp), end(tmp)), end(tmp));
		int c(0);

		for (int i(0); i < a.size(); ++i)
		if (find(tmp.begin(), tmp.end(), a[i]) == tmp.end())
			++c;

		if (c == 0)
			return PC0;
		else if (c == 1)
			return PC1;
		else
			return PC2;
	}

	void transpose(vector<vector<person>>& a, vector<vector<person>>& b) {
		for (int i = 0; i < a.size(); ++i) {
			for (int j = 0; j < a[i].size(); ++j) {
				b[j].push_back(a[i][j]);
			}
			vector<person>().swap(a[i]);
		}
		vector<vector<person>>().swap(a);
	}

	void generate_persons() {
		for (int i(0); i < g.alleles.size(); ++i) {
			for (int j(i); j < g.alleles.size(); ++j) {
				persons.push_back(person("Unknown", g.alleles[i], g.alleles[j]));
			}
		}
	}

	void check_person() {
		bool found_two = false;
		bool found_a = false;
		bool found_b = false;
		for (int i(0); i < rep_alleles.size(); ++i) {
			for (int j(0); j < rep_alleles[i].size(); ++j) {
				if (s.a == rep_alleles[i][j]) {
					found_a = true;
				}
				if (s.b == rep_alleles[i][j]) {
					found_b = true;
				}
			}
		}
		
		if (found_a && !found_b) {
			s.b = persons[persons.size() - 1].b;
			s.generate_freq();
		}
		if (!found_a && found_b) {
			s.a = persons[persons.size() - 1].a;
			s.generate_freq();
		}
		if (s.a == s.b) {
			s.hom = true;
			s.het = false;
		}
		else {
			s.het = true;
			s.hom = false;
		}
	}

	person get_suspect() const { return s; }

	int get_unknowns() const { return unknowns; }

	double get_LR() const { return LR; }

	vector<person>& get_persons() { return persons; }

	vector<double>& get_LRs() { return LRs; }

private:
	double numerator_sum;
	double denominator_sum;
	double LR;

	vector<double> LRs;
	vector<double> numerators;
	vector<person> persons;
	vector<vector<allele>> rep_alleles;
	vector<vector<person>> population;		// Population accounted for in the demominator
	vector<vector<person>> population_t;
	vector<vector<int>> indicies;

	person s;								// Suspect profile for two alleles at a specific locus - used for numerator
	geno_f g;
	int rep_num;
	int unknowns;
	bool flag;

	friend allele;
	friend geno_f;
	friend person;
};

double generate_wild_allele_freq(vector<allele>& alleles) {
	double c(1.0);
	for (int i(0); i < alleles.size(); ++i) {
		c -= alleles[i].get_freq();
	}
	return c;
}

double get_input_freq(CSVDatabase& db, string& locus, double length, char race) {
	for (int i(0); i < db.size(); ++i) {
		for (int j(0); j < db[i].size(); ++j) {
			if (db[i][j] == locus && atof(db[i][j + 1].c_str()) == length && race == 'b')
				return atof(db[i][j + 2].c_str());
			else if (db[i][j] == locus && atof(db[i][j + 1].c_str()) == length && race == 'c')
				return atof(db[i][j + 3].c_str());
			else if (db[i][j] == locus && atof(db[i][j + 1].c_str()) == length && race == 'h')
				return atof(db[i][j + 4].c_str());
			else if (db[i][j] == locus && atof(db[i][j + 1].c_str()) == length && race == 'a')
				return atof(db[i][j + 5].c_str());
		}
	}
	cout << "Frequency not found - LR given will most likely be wrong!" << endl;
	return 0.0;
}

string get_input_freq_string(CSVDatabase& db, string locus, string length, char race) {
	for (int i(0); i < db.size(); ++i) {
		for (int j(0); j < db[i].size(); ++j) {
			if (db[i][j] == locus && db[i][j + 1] == length && race == 'b')
				return db[i][j + 2];
			else if (db[i][j] == locus && db[i][j + 1] == length && race == 'c')
				return db[i][j + 3];
			else if (db[i][j] == locus && db[i][j + 1] == length && race == 'h')
				return db[i][j + 4];
			else if (db[i][j] == locus && db[i][j + 1] == length && race == 'a')
				return db[i][j + 5];
		}
	}
	string str = "0.0";
	return str;
}

double read_csv(CSVDatabase& db, string db_name) {
	ifstream ifs(db_name);
	String csvLine;
	while (getline(ifs, csvLine)){
		istringstream csvStream(csvLine);
		CSVRow csvRow;
		String csvCol;
		while (getline(csvStream, csvCol, ','))
			csvRow.push_back(csvCol);
		db.push_back(csvRow);
	}
	ifs.close();
	return true;
}

person get_data(CSVDatabase& db, CSVDatabase& adb, vector<vector<allele>>& a, vector<allele>& b, int& c, int& q, char race) {
	string locus;
	string name("Suspect");
	vector<allele> s_tmp;
	vector<allele> r_tmp;
	for (int i(0); i < db[0].size(); ++i) {
		if (db[0][i] == "Suspect Name")
			name = db[1][i];
		else if (db[0][i] == "Locus")
			locus = db[1][i];
		else if (db[0][i] == "Contributors")
			c = atof(db[1][i].c_str());
		else if (db[0][i] == "Quant")
			q = atof(db[1][i].c_str());
		else if (db[0][i] == "Alleles") {
			istringstream csvCell(db[1][i]);
			string sub_cell;
			while (getline(csvCell, sub_cell, ';')) {
				allele tmp_a(locus, atof(sub_cell.c_str()), get_input_freq(adb, locus, atof(sub_cell.c_str()), race), true);
				b.push_back(tmp_a);
			}
		}
		else if (db[0][i] == "Suspect Alleles") {
			istringstream csvCell(db[1][i]);
			string sub_cell;
			while (getline(csvCell, sub_cell, ';')) {
				allele tmp_a(locus, atof(sub_cell.c_str()), get_input_freq(adb, locus, atof(sub_cell.c_str()), race), true);
				s_tmp.push_back(tmp_a);
			}
		}
		else if (db[0][i] == "D/ND") {
			if (db[1][i] == "d" || db[1][i] == "D") {
				DEDUCIBLE = true;
			}
			else if (db[1][i] == "nd" || db[1][i] == "ND") {
				DEDUCIBLE = false;
			}
			else if (db[1][i] != "d" && db[1][i] != "D" && db[1][i] != "nd" && db[1][i] != "ND") {
				cout << "Error in the D/ND column!" << endl;
			}
		}
		else if (db[0][i] == "HET0") {
			PHET0 = atof(db[1][i].c_str());
			double full(1.0);
			PHET1 = full - (PHET2 + PHET0);
		}
		else if (db[0][i] == "REP") {
			istringstream csvCell(db[1][i]);
			string sub_cell;
			while (getline(csvCell, sub_cell, ';')) {
				allele tmp_a(locus, atof(sub_cell.c_str()), get_input_freq(adb, locus, atof(sub_cell.c_str()), race), true);
				r_tmp.push_back(tmp_a);
			}
			a.push_back(r_tmp);
			r_tmp.clear();
		}
	}
	double freq = generate_wild_allele_freq(b);
	allele wild(locus + "-W", -1, freq, true);
	b.push_back(wild);
	return person(name, s_tmp[0], s_tmp[1]);
}

vector<string> run_LAST(vector<vector<string>>& allele_database, vector<vector<string>>& dordb, int e, char race) {
	timer time;
	double nuClicks;

	vector<vector<string>> evidence_database;
	read_csv(evidence_database, "Evidence_" + to_string(e) + ".csv");

	vector<vector<allele>> replicates;
	vector<allele> alleles;
	int contributors(2);
	int quant(100);
	string dnd("N");
	person suspect = get_data(evidence_database, allele_database, replicates, alleles, contributors, quant, race);
	if (quant < 100) {
		PC0 = 0.96;
		PC1 = 0.035;
		PC2 = 0.005;
	}
	else {
		PC0 = 0.975;
		PC1 = 0.02;
		PC2 = 0.005;
	}
	if (DEDUCIBLE) dnd = "D";
	else dnd = "ND";

	double full(1.0);
	for (int i(0); i < dordb.size(); ++i) {
		for (int j(0); j < dordb[i].size(); ++j) {
			if (dordb[i][j] == "HOM1-" + to_string(contributors) + "-" + dnd && dordb[i][j + 1] == suspect.get_a().get_locus() && quant >= 25 && quant < 50) {
				double b(0.0), l(25.0), h(50.0);
				double slope((atof(dordb[i][j + 3].c_str()) - atof(dordb[i][j + 2].c_str())) / (h - l));
				b = atof(dordb[i][j + 2].c_str()) - slope * l;
				PHOM1 = slope * quant + b;
				PHOM0 = full - PHOM1;

			}
			else if (dordb[i][j] == "HOM1-" + to_string(contributors) + "-" + dnd && dordb[i][j + 1] == suspect.get_a().get_locus() && quant >= 50 && quant < 100) {
				double b(0.0), l(50.0), h(100.0);
				double slope((atof(dordb[i][j + 4].c_str()) - atof(dordb[i][j + 3].c_str())) / (h - l));
				b = atof(dordb[i][j + 3].c_str()) - slope * l;
				PHOM1 = slope * quant + b;
				PHOM0 = full - PHOM1;
			}
			else if (dordb[i][j] == "HOM1-" + to_string(contributors) + "-" + dnd && dordb[i][j + 1] == suspect.get_a().get_locus() && quant >= 100 && quant < 150) {
				double b(0.0), l(100.0), h(150.0);
				double slope((atof(dordb[i][j + 5].c_str()) - atof(dordb[i][j + 4].c_str())) / (h - l));
				b = atof(dordb[i][j + 4].c_str()) - slope * l;
				PHOM1 = slope * quant + b;
				PHOM0 = full - PHOM1;
			}
			else if (dordb[i][j] == "HOM1-" + to_string(contributors) + "-" + dnd && dordb[i][j + 1] == suspect.get_a().get_locus() && quant >= 150 && quant < 250) {
				double b(0.0), l(150.0), h(250.0);
				double slope((atof(dordb[i][j + 6].c_str()) - atof(dordb[i][j + 5].c_str())) / (h - l));
				b = atof(dordb[i][j + 5].c_str()) - slope * l;
				PHOM1 = slope * quant + b;
				PHOM0 = full - PHOM1;
			}
			else if (dordb[i][j] == "HOM1-" + to_string(contributors) + "-" + dnd && dordb[i][j + 1] == suspect.get_a().get_locus() && quant >= 250 && quant < 500) {
				double b(0.0), l(250.0), h(500.0);
				double slope((atof(dordb[i][j + 7].c_str()) - atof(dordb[i][j + 6].c_str())) / (h - l));
				b = atof(dordb[i][j + 6].c_str()) - slope * l;
				PHOM1 = slope * quant + b;
				PHOM0 = full - PHOM1;
			}

			else if (dordb[i][j] == "HET1-" + to_string(contributors) + "-" + dnd && dordb[i][j + 1] == suspect.get_a().get_locus() && quant >= 25 && quant < 50) {
				double b(0.0), l(25.0), h(50.0);
				double slope((atof(dordb[i][j + 3].c_str()) - atof(dordb[i][j + 2].c_str())) / (h - l));
				b = atof(dordb[i][j + 2].c_str()) - slope * l;
				PHET1 = slope * quant + b;
			}
			else if (dordb[i][j] == "HET1-" + to_string(contributors) + "-" + dnd && dordb[i][j + 1] == suspect.get_a().get_locus() && quant >= 50 && quant < 100) {
				double b(0.0), l(50.0), h(100.0);
				double slope((atof(dordb[i][j + 4].c_str()) - atof(dordb[i][j + 3].c_str())) / (h - l));
				b = atof(dordb[i][j + 3].c_str()) - slope * l;
				PHET1 = slope * quant + b;
			}
			else if (dordb[i][j] == "HET1-" + to_string(contributors) + "-" + dnd && dordb[i][j + 1] == suspect.get_a().get_locus() && quant >= 100 && quant < 150) {
				double b(0.0), l(100.0), h(150.0);
				double slope((atof(dordb[i][j + 5].c_str()) - atof(dordb[i][j + 4].c_str())) / (h - l));
				b = atof(dordb[i][j + 4].c_str()) - slope * l;
				PHET1 = slope * quant + b;
			}
			else if (dordb[i][j] == "HET1-" + to_string(contributors) + "-" + dnd && dordb[i][j + 1] == suspect.get_a().get_locus() && quant >= 150 && quant < 250) {
				double b(0.0), l(150.0), h(250.0);
				double slope((atof(dordb[i][j + 6].c_str()) - atof(dordb[i][j + 5].c_str())) / (h - l));
				b = atof(dordb[i][j + 5].c_str()) - slope * l;
				PHET1 = slope * quant + b;
			}
			else if (dordb[i][j] == "HET1-" + to_string(contributors) + "-" + dnd && dordb[i][j + 1] == suspect.get_a().get_locus() && quant >= 250 && quant < 500) {
				double b(0.0), l(250.0), h(500.0);
				double slope((atof(dordb[i][j + 7].c_str()) - atof(dordb[i][j + 6].c_str())) / (h - l));
				b = atof(dordb[i][j + 6].c_str()) - slope * l;
				PHET1 = slope * quant + b;
			}

			else if (dordb[i][j] == "HET2-" + to_string(contributors) + "-" + dnd && dordb[i][j + 1] == suspect.get_a().get_locus() && quant >= 25 && quant < 50) {
				double b(0.0), l(25.0), h(50.0);
				double slope((atof(dordb[i][j + 3].c_str()) - atof(dordb[i][j + 2].c_str())) / (h - l));
				b = atof(dordb[i][j + 2].c_str()) - slope * l;
				PHET2 = slope * quant + b;
				PHET0 = full - (PHET1 + PHET2);
			}
			else if (dordb[i][j] == "HET2-" + to_string(contributors) + "-" + dnd && dordb[i][j + 1] == suspect.get_a().get_locus() && quant >= 50 && quant < 100) {
				double b(0.0), l(50.0), h(100.0);
				double slope((atof(dordb[i][j + 4].c_str()) - atof(dordb[i][j + 3].c_str())) / (h - l));
				b = atof(dordb[i][j + 3].c_str()) - slope * l;
				PHET2 = slope * quant + b;
				PHET0 = full - (PHET1 + PHET2);
			}
			else if (dordb[i][j] == "HET2-" + to_string(contributors) + "-" + dnd && dordb[i][j + 1] == suspect.get_a().get_locus() && quant >= 100 && quant < 150) {
				double b(0.0), l(100.0), h(150.0);
				double slope((atof(dordb[i][j + 5].c_str()) - atof(dordb[i][j + 4].c_str())) / (h - l));
				b = atof(dordb[i][j + 4].c_str()) - slope * l;
				PHET2 = slope * quant + b;
				PHET0 = full - (PHET1 + PHET2);
			}
			else if (dordb[i][j] == "HET2-" + to_string(contributors) + "-" + dnd && dordb[i][j + 1] == suspect.get_a().get_locus() && quant >= 150 && quant < 250) {
				double b(0.0), l(150.0), h(250.0);
				double slope((atof(dordb[i][j + 6].c_str()) - atof(dordb[i][j + 5].c_str())) / (h - l));
				b = atof(dordb[i][j + 5].c_str()) - slope * l;
				PHET2 = slope * quant + b;
				PHET0 = full - (PHET1 + PHET2);
			}
			else if (dordb[i][j] == "HET2-" + to_string(contributors) + "-" + dnd && dordb[i][j + 1] == suspect.get_a().get_locus() && quant >= 250 && quant < 500) {
				double b(0.0), l(250.0), h(500.0);
				double slope((atof(dordb[i][j + 7].c_str()) - atof(dordb[i][j + 6].c_str())) / (h - l));
				b = atof(dordb[i][j + 6].c_str()) - slope * l;
				PHET2 = slope * quant + b;
				PHET0 = full - (PHET1 + PHET2);
			}
		}
	}

	geno_f genotypes(alleles);
	rep report(contributors, suspect, genotypes, replicates);

	vector<string> info;
	info.push_back(suspect.get_name());
	info.push_back(alleles[0].get_locus());
	info.push_back(to_string(report.get_LR()));

	nuClicks = time.elapsed();

	info.push_back(to_string(nuClicks));

	for (int i(0); i < report.get_persons().size() && i < report.get_LRs().size(); ++i) {
		info.push_back(to_string(report.get_persons()[i].get_a().get_length()));
		info.push_back(to_string(report.get_persons()[i].get_b().get_length()));
		info.push_back(to_string(report.get_LRs()[i]));
	}

	return info;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//
// MAIN
//
//

allele NULL_ALLELE("NULL", 0.0, 0.0, false);	// Not to be confused with WILD (w) allele
// Stops argument list - Used in previous versions of LAST for Vardic classes and functions

int main() {

	cout << "///////////////////////////////////////////////////////" << endl;
	cout << "//" << endl;
	cout << "//\tWELCOME TO LEGAL AID STATISTICAL TOOL" << endl;
	cout << "//" << endl;
	cout << "//" << endl;
	cout << "\n________________________________________________\n" << endl;
	timer time;
	ofstream ofs("output.txt");
	double nuClicks(0.0);

	vector<vector<string>> allele_database(6);
	read_csv(allele_database, "Allele_Frequencies.csv");
	vector<vector<string>> drop_out_rates_database(8);
	read_csv(drop_out_rates_database, "Drop_Out_Rates.csv");

	time.reset();
	while (true) {
		ifstream ifs("Evidence_" + to_string(FILE_NUM) + ".csv");
		if (ifs) {
			cout << "\nRunning Analysis for Black" << endl;
			ofs << "\nAnalysis for Black" << endl;
			vector<string> vb = run_LAST(allele_database, drop_out_rates_database, FILE_NUM, 'b');
			ofs << "\tHET0:\t" << PHET0 << "\t\tpC0:\t" << PC0 << "\n\tHET1:\t" << PHET1 << "\t\tpC1:\t" << PC1
				<< "\n\tHET2:\t" << PHET2 << "\t\tpC2:\t" << PC2 << "\n\tHOM0:\t" << PHOM0 << "\n\tHOM1:\t" << PHOM1 << endl;
			ofs << "\tSuspect:\t\t" << vb[0] << endl;
			ofs << "\tlocus:\t\t\t" << vb[1] << endl;
			ofs << "\tLikelihood Ratio:\t" << vb[2] << endl;
			for (int i(4); i < vb.size() - 2; i += 3)
				ofs << "\tLR for: " << atof(vb[i].c_str()) << ",\t" << atof(vb[i + 1].c_str()) << "\t=\t" << atof(vb[i + 2].c_str()) << endl;
			vb.clear();
			++RACE;

			cout << "\nRunning Analysis for Caucasian" << endl;
			ofs << "\nAnalysis for Caucasian" << endl;
			vector<string> vc = run_LAST(allele_database, drop_out_rates_database, FILE_NUM, 'c');
			ofs << "\tHET0:\t" << PHET0 << "\t\tpC0:\t" << PC0 << "\n\tHET1:\t" << PHET1 << "\t\tpC1:\t" << PC1
				<< "\n\tHET2:\t" << PHET2 << "\t\tpC2:\t" << PC2 << "\n\tHOM0:\t" << PHOM0 << "\n\tHOM1:\t" << PHOM1 << endl;
			ofs << "\tSuspect:\t\t" << vc[0] << endl;
			ofs << "\tlocus:\t\t\t" << vc[1] << endl;
			ofs << "\tLikelihood Ratio:\t" << vc[2] << endl;
			for (int i(4); i < vc.size() - 2; i += 3)
				ofs << "\tLR for: " << atof(vc[i].c_str()) << ",\t" << atof(vc[i + 1].c_str()) << "\t=\t" << atof(vc[i + 2].c_str()) << endl;
			vc.clear();
			++RACE;

			cout << "\nRunning Analysis for Hispanic" << endl;
			ofs << "\nAnalysis for Hispanic" << endl;
			vector<string> vh = run_LAST(allele_database, drop_out_rates_database, FILE_NUM, 'h');
			ofs << "\tHET0:\t" << PHET0 << "\t\tpC0:\t" << PC0 << "\n\tHET1:\t" << PHET1 << "\t\tpC1:\t" << PC1
				<< "\n\tHET2:\t" << PHET2 << "\t\tpC2:\t" << PC2 << "\n\tHOM0:\t" << PHOM0 << "\n\tHOM1:\t" << PHOM1 << endl;
			ofs << "\tSuspect:\t\t" << vh[0] << endl;
			ofs << "\tlocus:\t\t\t" << vh[1] << endl;
			ofs << "\tLikelihood Ratio:\t" << vh[2] << endl;
			for (int i(4); i < vh.size() - 2; i += 3)
				ofs << "\tLR for: " << atof(vh[i].c_str()) << ",\t" << atof(vh[i + 1].c_str()) << "\t=\t" << atof(vh[i + 2].c_str()) << endl;
			vh.clear();
			++RACE;

			cout << "\nRunning Analysis for Asian" << endl;
			ofs << "\nAnalysis for Asian" << endl;
			vector<string> va = run_LAST(allele_database, drop_out_rates_database, FILE_NUM, 'a');
			ofs << "\tHET0:\t" << PHET0 << "\t\tpC0:\t" << PC0 << "\n\tHET1:\t" << PHET1 << "\t\tpC1:\t" << PC1
				<< "\n\tHET2:\t" << PHET2 << "\t\tpC2:\t" << PC2 << "\n\tHOM0:\t" << PHOM0 << "\n\tHOM1:\t" << PHOM1 << endl;
			ofs << "\tSuspect:\t\t" << va[0] << endl;
			ofs << "\tlocus:\t\t\t" << va[1] << endl;
			ofs << "\tLikelihood Ratio:\t" << va[2] << endl;
			for (int i(4); i < va.size() - 2; i += 3)
				ofs << "\tLR for: " << atof(va[i].c_str()) << ",\t" << atof(va[i + 1].c_str()) << "\t=\t" << atof(va[i + 2].c_str()) << endl;
			va.clear();
			RACE = 1;
		}
		ofs << "\n_____________________________________________________________\n" << endl;
		cout << "\n________________________________________________\n" << endl;
		++FILE_NUM;
		if (FILE_NUM == 16) {
			FILE_NUM = 1;
			break;
		}
	}

	nuClicks = time.elapsed();
	cout << "\n\tTime to run:\t" << nuClicks << " second(s)" << endl;
	cout << "\n\t\tLAST Analysis Finished!\n" << endl;
	ofs << "\n\tTime to run:\t" << nuClicks << " second(s)" << endl;
	ofs.close();

}