//
//	Legal Aid Society Tool
//	Team:	Clinton Hughes
//			Nicolas Corpus
//			Khaguy Nagdimov
//			Munieshwar Ramdass
//	June 2nd, 2015 - August 14th, 2015
//

//
//	Application security has not been done
//	Simple procedures like checking for const methods or variables, or passing by references may not have been done
//	Code was written to work without regards to runtime or performance
//

#include <vector>
#include <string>
#include <iostream>
#include <fstream>
#include <sstream>
#include <cstring>
#include <ctime>
#include <cstdlib>
#include <list>
#include <algorithm>
#include <iterator>
#include <functional>
#include <limits>
#include <map>
#include <unordered_map>
#include <stack>
#include <queue>
#include <cassert>
#include <windows.h>
//#include "resource.h"
#include <stdlib.h>
#include <iomanip>
#include <stdio.h>
#include <math.h>

using namespace std;

class timer {
public:
	timer() : start(clock()) {}
	double elapsed() { return (clock() - start) / CLOCKS_PER_SEC; }
	void reset() { start = clock(); }
private:
	double start;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Information gathering
// Report generation
// File type and formating must be checked
//
//

// Parameters: string& filename
class Report {
public:
	Report(string& filename)
		: filename(filename), template_amt(100), profile_s(15), profile_1(15), profile_2(15), profile_3(15){
		bool status = read_file(filename);
		active = status;
		if (active) run();
	}

	void run(){};

private:
	vector < vector<float >> profile_s;
	vector < vector<float >> profile_1;
	vector < vector<float >> profile_2;
	vector < vector<float >> profile_3;
	int template_amt;
	bool active;
	string filename;
	char* context = NULL;

	bool read_file(string& name){
		ifstream ifs(name);
		if (!ifs) {
			cerr << "File has not opened successfully." << endl;
			return false;
		}

		string line;
		//getline(ifs, line); // Ignoring first line

		int counter(0);
		vector<string> tokens;

		while (getline(ifs, line)) {
			tokens.clear();
			char str[256];
			strcpy_s(str, line.c_str());
			char* pch;
			pch = strtok_s(str, ",", &context);
			while (pch) {
				tokens.push_back(pch);
				pch = strtok_s(nullptr, ",", &context);
			}
			for (int i(0); i < tokens.size(); ++i){
				if (counter == 0)
					profile_s[counter].push_back(atof(tokens[i].c_str()));
				else if (counter == 1)
					profile_1[counter].push_back(atof(tokens[i].c_str()));
				else if (counter == 2)
					profile_2[counter].push_back(atof(tokens[i].c_str()));
				else if (counter == 3)
					profile_3[counter].push_back(atof(tokens[i].c_str()));
			}
			++counter;
			if (counter > 3) counter = 0;
			delete[] pch;
		}

		ifs.close();
		return true;
	}

	friend ostream& operator<<(ostream& os, const Report& r);
};

ostream& operator<<(ostream& os, const Report& r){

	cout << "\nSuspect Profile:" << endl;
	for (int i(0); i < r.profile_s.size(); ++i){
		for (int j(0); j < r.profile_s[i].size(); ++j){
			cout << r.profile_s[i][j] << "\t";
		}
	}
	cout << "\nProfile 1:" << endl;
	for (int i(0); i < r.profile_1.size(); ++i){
		for (int j(0); j < r.profile_1[i].size(); ++j){
			cout << r.profile_1[i][j] << "\t";
		}
	}
	cout << "\nProfile 2:" << endl;
	for (int i(0); i < r.profile_2.size(); ++i){
		for (int j(0); j < r.profile_2[i].size(); ++j){
			cout << r.profile_2[i][j] << "\t";
		}
	}
	cout << "\nProfile 3:" << endl;
	for (int i(0); i < r.profile_3.size(); ++i){
		for (int j(0); j < r.profile_3[i].size(); ++j){
			cout << r.profile_3[i][j] << "\t";
		}
	}
	return os;
}


///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Calculations based on report
// Allele, Genotype Frequency generation
// Drop out/in analysis
//
//

double HOM_CONST = 0.03;	// inbreed constant

double PC0 = 0.96;			// Drop-in rates
double PC1 = 0.035;
double PC2 = 0.005;

//double PHET0 = 0.58;		// Drop-out rates
//double PHET1 = 0.4;
//double PHET2 = 0.02;
//double PHOM0 = 0.98;
//double PHOM1 = 0.02;

double PHET0 = 0.9124;		// Drop-out rates
double PHET1 = 0.0676;
double PHET2 = 0.02;
double PHOM0 = 0.98;
double PHOM1 = 0.02;

//double PHET0 = 0.8772;		// Drop-out rates
//double PHET1 = 0.1028;
//double PHET2 = 0.02;
//double PHOM0 = 0.98;
//double PHOM1 = 0.02;

class geno_f;
class person;
class rep;

// Parameters: string lotus, float length, float freq, bool flag
class allele {
public:
	allele(string lotus, float length, double freq, bool flag)
		:lotus(lotus), length(length), freq(freq), flag(flag) {}

	bool operator==(const allele& right) const {
		return (lotus == right.lotus && length == right.length && freq == right.freq && flag == right.flag);
	}

	bool operator!=(const allele& right) const {
		return !(*this == right);
	}

	string get_lotus() { return lotus; }

private:
	string lotus;
	float length;
	double freq;
	bool flag;

	friend geno_f;
	friend person;
	friend rep;
};

// Parameters: allele a, ...
class geno_f {
public:
	geno_f(allele a, ...)
		: flag(true){
		//allele input;
		va_list v;
		allele input = a;
		va_start(v, a);
		while (input.flag) {
			alleles.push_back(input);
			input = va_arg(v, allele);
		}
		va_end(v);

		generate_allele_pairs();
		generate_freqs();
	}

	void print_alleles() {
		for (int i(0); i < alleles.size(); ++i){
			cout << "\tLotus:\t\t" << alleles[i].lotus
				<< "\n\tLength:\t\t" << alleles[i].length << "\n\tFrequency:\t" << alleles[i].freq << endl;
		}
	}

	void print_freqs() {
		for (int i(0); i < freqs.size(); ++i){
			cout << "\tCombinations: " << i + 1 << " " << freqs[i] << endl;
		}
	}

	void generate_freqs() {
		for (int i(0); i < alleles.size(); ++i){
			for (int j(i); j < alleles.size(); ++j){
				if (i == j){
					freqs.push_back(calc_hom(alleles[i]));
				}
				else{
					freqs.push_back(calc_het(alleles[i], alleles[j]));
				}
			}
		}
	}

	void generate_allele_pairs() {
		for (int i(0); i < alleles.size(); ++i){
			for (int j(i); j < alleles.size(); ++j){
				allele_comb.push_back(pair<allele, allele>(alleles[i], alleles[j]));
			}
		}
	}

	double calc_hom(allele a) const {
		return a.freq * a.freq + a.freq * HOM_CONST * (1 - a.freq);
	}

	double calc_het(allele a, allele b) const {
		return 2 * a.freq * b.freq;
	}


private:
	vector<allele> alleles;
	vector<pair<allele, allele>> allele_comb;
	vector<double> freqs;
	bool flag;

	friend allele;
	friend person;
	friend rep;
};

class person {
public:
	person(string name, allele a, allele b)
		: name(name), a(a), b(b) {
		generate_freq();
		if (a == b) {
			hom = true;
			het = false;
		}
		else {
			hom = false;
			het = true;
		}
	}

	void print_alleles() {
		cout << name << "'s Alleles:" << endl;
		cout << "First Allele:" << endl;
		cout << "\tLotus:\t\t\t" << a.lotus
			<< "\n\tLength:\t\t\t" << a.length << "\n\tFrequency:\t\t" << a.freq << endl;
		cout << "Second Allele:" << endl;
		cout << "\tLotus:\t\t\t" << b.lotus
			<< "\n\tLength:\t\t\t" << b.length << "\n\tFrequency:\t\t" << b.freq << endl;
		cout << "\tGenotype Frequency:\t" << freq << endl;
	}

	void generate_freq() {
		if (a == b){
			freq = calc_hom(a);
		}
		else{
			freq = calc_het(a, b);
		}
	}

	double calc_hom(allele a) const {
		return a.freq * a.freq + a.freq * HOM_CONST * (1 - a.freq);
	}

	double calc_het(allele a, allele b) const {
		return 2 * a.freq * b.freq;
	}

	bool operator==(const person& right) const {
		return (a == right.a && b == right.b && freq == right.freq && hom == right.hom && het == right.het);
	}
	bool operator!=(const person& right) const {
		return !(*this == right);
	}

	string get_name() { return name; }

private:
	string name;
	allele a;
	allele b;
	double freq;
	bool hom;
	bool het;		// not necessary

	friend allele;
	friend geno_f;
	friend rep;
};

class rep {
public:
	rep(int unknowns, person s, geno_f g, vector<allele> a, ...)
		: flag(true), rep_num(0), s(s), g(g), unknowns(unknowns) {

		for (int i(0); i < unknowns; ++i) {
			vector<person> p;
			population.push_back(p);
		}

		va_list v;
		vector<allele> input = a;
		va_start(v, a);
		//rep_alleles.push_back(input);
		while (input[0].flag) {
			rep_alleles.push_back(input);
			input = va_arg(v, vector<allele>);
			++rep_num;
		}
		va_end(v);

		//generate_persons();			// NOT NECESSARY

		vector<int> tmp;
		for (int i(0); i < g.allele_comb.size(); ++i) {
			tmp.push_back(i);
		}
		permute_vector_driver(tmp, unknowns);

		generate_population();
		for (int i(0); i < population[0].size(); ++i) {
			vector<person> p;
			population_t.push_back(p);
		}
		transpose(population, population_t);
		generate_numerator_sum();
		cout << "Numerator:\t\t" << numerator_sum << endl;
		generate_denominator_sum();
		cout << "Denominator:\t\t" << denominator_sum << endl;
		LR = numerator_sum / denominator_sum;
		cout << "Likelihood Ratio:\t" << LR << endl;

		/*ofstream ofs("output_.txt");
		for (int i = 0; i < population_t.size(); ++i) {
			for (int j = 0; j < population_t[i].size(); ++j) {
				ofs << population_t[i][j].a.length << ", " << population_t[i][j].b.length << "\t\t";
			}
			ofs << endl;
		}
		ofs.close();*/

	}

	//void generate_persons() {					// NOT NECESSARY
	//	for (int i(0); i < g.alleles.size(); ++i){
	//		for (int j(i); j < g.alleles.size(); ++j) {
	//			persons.push_back(person("Unknown", g.alleles[i], g.alleles[j]));
	//		}
	//	}
	//	cout << endl;
	//}

	void permute_vector(const vector<int>& elems, unsigned long req_len, vector<unsigned long>& pos, unsigned long depth, unsigned long margin) {
		if (depth >= req_len) {
			vector<int> index_vector;

			for (unsigned long ii = 0; ii < pos.size(); ++ii) {
				index_vector.push_back(elems[pos[ii]]);
			}
			indicies.push_back(index_vector);
			return;
		}

		for (unsigned long ii = 0; ii < elems.size(); ++ii) { // CHANGE ii TO margin TO MAKE THIS A COMBINATION WITH REPETITION
			pos[depth] = ii;
			permute_vector(elems, req_len, pos, depth + 1, ii);
		}
		return;
	}

	void permute_vector_driver(const vector<int>& elems, unsigned long req_len) {
		assert(req_len > 0 && req_len <= elems.size());
		vector<unsigned long> positions(req_len, 0);
		permute_vector(elems, req_len, positions, 0, 0);
	}

	void generate_population(){
		for (int i(0); i < indicies.size(); ++i){
			for (int j(0); j < indicies[i].size(); ++j){
				person temp("Unknown", g.allele_comb[indicies[i][j]].first, g.allele_comb[indicies[i][j]].second);
				population[j].push_back(temp);

			}
		}
	}

	void generate_denominator_sum() {
		double sum(0.0);
		double prod(1.0);
		for (int i(0); i < population_t.size(); ++i){
			for (int j(0); j < population_t[i].size(); ++j){
					prod *= population_t[i][j].freq;
				}
				for (int j(0); j < population_t[i].size(); ++j){
					for (int k(0); k < rep_alleles.size(); ++k){
						prod *= drop_out(population_t[i][j], rep_alleles[k]);
					}
				}
				for (int j(0); j < rep_alleles.size(); ++j){
					prod *= drop_in(population_t[i], rep_alleles[j]);
				}
				sum += prod;
				prod = 1.0;
		}
		denominator_sum = sum;
	}

	void generate_numerator_sum() {
		double sum(0.0);
		double prod(1.0);
		for (int i(0); i < population_t.size(); ++i){
			if (population_t[i][0] == s) {
				for (int j(1); j < population_t[i].size(); ++j){
					prod *= population_t[i][j].freq;
				}
				for (int j(0); j < population_t[i].size(); ++j){
					for (int k(0); k < rep_alleles.size(); ++k){
						prod *= drop_out(population_t[i][j], rep_alleles[k]);
					}
				}
				for (int j(0); j < rep_alleles.size(); ++j){
					prod *= drop_in(population_t[i], rep_alleles[j]);
				}
				sum += prod;
				prod = 1.0;
			}
		}
		numerator_sum = sum;
	}

	double drop_out(person p, vector<allele>& v) {
		if (p.hom) {
			for (int i(0); i < v.size(); ++i) {
				if (p.a == v[i] && p.b == v[i])
					return PHOM0;
			}
			return PHOM1;
		}
		else if (p.het) {
			bool present_first = false;
			bool present_second = false;
			for (int i(0); i < v.size(); ++i) {
				if (p.a == v[i])
					present_first = true;
				if (p.b == v[i])
					present_second = true;
			}
			if (present_first && present_second)
				return PHET0;
			else if (!present_first && !present_second)
				return PHET2;
			else if ((present_first && !present_second) || (!present_first && present_second))
				return PHET1;
		}
	}
	
	double drop_in(vector<person>& p, vector<allele>& a) {
		vector<allele> tmp;
		for (int i(0); i < p.size(); ++i) {
			tmp.push_back(p[i].a);
			tmp.push_back(p[i].b);
		}
		tmp.erase(unique(begin(tmp), end(tmp)), end(tmp));
		int c(0);
		
		for (int i(0); i < a.size(); ++i)
			if (find(tmp.begin(), tmp.end(), a[i]) == tmp.end())
				++c;

		if (c == 0)
			return PC0;
		else if (c == 1)
			return PC1;
		else
			return PC2;
	}

	//void print_persons() {			// NOT NECESSARY
	//	cout << "\nPersons:" << endl;
	//	for (int i(0); i < persons.size(); ++i){
	//		cout << "\nName: " << persons[i].name << endl;
	//		persons[i].print_alleles();
	//	}
	//}

	void transpose(vector<vector<person>>& a, vector<vector<person>>& b) {
		for (int i = 0; i < a.size(); ++i) {
			for (int j = 0; j < a[i].size(); ++j) {
				b[j].push_back(a[i][j]);
			}
			vector<person>().swap(a[i]);
		}
		vector<vector<person>>().swap(a);
	}



	// GETTERS

	person get_suspect() { return s; }

	int get_unknowns() { return unknowns; }

	double get_LR() { return LR; }

private:
	double numerator_sum;
	double denominator_sum;
	double LR;

	vector<vector<allele>> rep_alleles;
	//vector<person> persons;				// NOT NECESSARY - All possible persons for given alleles
	vector<vector<person>> population;		// Population accounted for in the demominator
	vector<vector<person>> population_t;
	vector<vector<int>> indicies;

	person s;								// Suspect profile for two alleles at a specific lotus - used for numerator
	geno_f g;
	int rep_num;
	int unknowns;
	bool flag;

	friend allele;
	friend geno_f;
	friend person;
};



///////////////////////////////////////////////////////////////////////////////////////////////////
//
// MAIN
//
//

allele NULL_ALLELE("NULL", 0.0, 0.0, false);	// Not to be confused with WILD (w) allele
// Stops argument list

int main() {

	string filename("evidence.txt");
	Report R(filename);
	//cout << R << endl;

	// CSV Handling
	/*
	ifstream indata;
	ofstream outdata;
	outdata.open("test.csv", ios::app);
	outdata << "a1,b1,c1" << endl;
	outdata << "a2,b2,c2" << endl;
	outdata << "a2,b2,c2" << endl;
	outdata << "a2,b2,c2" << endl;
	outdata << "a2,b2,c2" << endl;
	//indata.open("test.csv");
	//string cell1;

	//indata >> cell1;

	//cout << cell1 << "\n\n";
	*/


	// ====================================================
	timer time;
	ofstream ofs("output.txt");
	double nuClicks;
	/*
	time.reset();
	cout << "START LAST TESTING EXAMPLE 20\n" << endl;
	allele a("D19S433", 13, 0.289, true);
	allele b("D19S433", 14, 0.341, true);
	allele w("WILD", -1, 0.37, true);

	person s("Dude from Example 20", a, b);

	geno_f g(a, b, w, NULL_ALLELE);

	vector<allele> rep1;
	vector<allele> rep2;
	rep1.push_back(a);
	rep1.push_back(b);
	rep2.push_back(a);
	vector<allele> rep_stop;
	rep_stop.push_back(NULL_ALLELE);
	rep report1(3, s, g, rep1, rep2, rep_stop);

	ofs << "\tSuspect:\t" << report1.get_suspect().get_name() << endl;
	ofs << "\tLotus:\t\t" << a.get_lotus() << endl;
	ofs << "\tLR:\t\t\t" << report1.get_LR() << endl;
	nuClicks = time.elapsed();
	cout << "Runtime:\t\t" << nuClicks << endl;
	ofs << "\tRuntime:\t" << nuClicks << endl << endl;
	cout << "==========\tEND\t==========" << endl;

	
	time.reset();
	cout << "START LAST TESTING JB PERSON\n" << endl;
	allele c("CSF", 9, 0.033, true);
	allele d("CSF", 10, 0.264, true);
	allele e("CSF", 12, 0.277, true);
	allele w1("WILD", -1, 0.426, true);

	person t("JB", d, d);

	geno_f h(c, d, e, w1, NULL_ALLELE);

	vector<allele> rep3;
	vector<allele> rep4;
	vector<allele> rep5;
	rep3.push_back(c);
	rep3.push_back(d);
	rep3.push_back(e);
	rep4.push_back(d);
	rep4.push_back(e);
	rep5.push_back(c);
	rep5.push_back(d);
	rep5.push_back(e);
	vector<allele> rep_stop1;
	rep_stop1.push_back(NULL_ALLELE);
	rep report2(3, t, h, rep3, rep4, rep5, rep_stop1);

	ofs << "\tSuspect:\t" << report2.get_suspect().get_name() << endl;
	ofs << "\tLotus:\t\t" << c.get_lotus() << endl;
	ofs << "\tLR:\t\t\t" << report2.get_LR() << endl;
	nuClicks = time.elapsed();
	cout << "Runtime:\t\t" << nuClicks << endl;
	ofs << "\tRuntime:\t" << nuClicks << endl;
	cout << "==========\tEND\t==========" << endl;
	*/
	/*
	time.reset();
	allele a("D3S1358", 14, 0.068, true);
	allele b("D3S1358", 15, 0.312, true);
	allele c("D3S1358", 16, 0.292, true);
	allele d("D3S1358", 17, 0.24, true);
	allele e("D3S1358", 18, 0.064, true);
	allele w("WILD", -1, 0.024, true);

	person s("Burke.44.D3.5", d, e);

	geno_f h(a, b, c, d, e, w, NULL_ALLELE);

	vector<allele> rep1;
	vector<allele> rep2;
	vector<allele> rep3;
	rep1.push_back(a);
	rep1.push_back(b);
	rep1.push_back(c);
	rep1.push_back(d);
	rep1.push_back(e);
	rep2.push_back(a);
	rep2.push_back(b);
	rep2.push_back(c);
	rep2.push_back(d);
	rep2.push_back(e);
	rep3.push_back(a);
	rep3.push_back(b);
	rep3.push_back(c);
	rep3.push_back(d);
	rep3.push_back(e);
	vector<allele> rep_stop1;
	rep_stop1.push_back(NULL_ALLELE);
	rep report2(3, s, h, rep1, rep2, rep3, rep_stop1);

	ofs << "\tSuspect:\t" << report2.get_suspect().get_name() << endl;
	ofs << "\tLotus:\t\t" << a.get_lotus() << endl;
	ofs << "\tLR:\t\t\t" << report2.get_LR() << endl;
	nuClicks = time.elapsed();
	cout << "Runtime:\t\t" << nuClicks << endl;
	ofs << "\tRuntime:\t" << nuClicks << endl << endl;
	*/
	
	/*
	time.reset();
	allele a("D2S1338", 16, 0.053, true);
	allele b("D2S1338", 18, 0.056, true);
	allele c("D2S1338", 19, 0.142, true);
	allele d("D2S1338", 21, 0.14, true);
	allele w("WILD", -1, 0.609, true);

	person s("Burke.44.D2.4", a, d);

	geno_f h(a, b, c, d, w, NULL_ALLELE);

	vector<allele> rep1;
	vector<allele> rep2;
	vector<allele> rep3;

	rep1.push_back(c);
	rep1.push_back(d);
	
	rep2.push_back(a);
	rep2.push_back(b);
	
	rep3.push_back(b);
	rep3.push_back(c);
	
	vector<allele> rep_stop1;
	rep_stop1.push_back(NULL_ALLELE);
	rep report2(3, s, h, rep1, rep2, rep3, rep_stop1);

	ofs << "\tSuspect:\t" << report2.get_suspect().get_name() << endl;
	ofs << "\tLotus:\t\t" << a.get_lotus() << endl;
	ofs << "\tLR:\t\t\t" << report2.get_LR() << endl;
	nuClicks = time.elapsed();
	cout << "Runtime:\t\t" << nuClicks << endl;
	ofs << "\tRuntime:\t" << nuClicks << endl << endl;
	*/
	
	/*
	time.reset();
	allele a("TPOX", 8, 0.324, true);
	allele b("TPOX", 9, 0.212, true);
	allele c("TPOX", 10, 0.104, true);
	allele d("TPOX", 11, 0.28, true);
	allele w("WILD", -1, 0.08, true);
	
	person s("Burke.44.TPOX.4", a, b);
	
	geno_f h(a, b, c, d, w, NULL_ALLELE);

	vector<allele> rep1;
	vector<allele> rep2;
	vector<allele> rep3;

	rep1.push_back(a);
	rep1.push_back(b);
	rep1.push_back(d);

	rep2.push_back(a);
	rep2.push_back(c);
	rep2.push_back(d);

	rep3.push_back(a);
	rep3.push_back(d);

	vector<allele> rep_stop1;
	rep_stop1.push_back(NULL_ALLELE);
	rep report2(3, s, h, rep1, rep2, rep3, rep_stop1);
	
	ofs << "\tSuspect:\t" << report2.get_suspect().get_name() << endl;
	ofs << "\tLotus:\t\t" << a.get_lotus() << endl;
	ofs << "\tLR:\t\t\t" << report2.get_LR() << endl;
	nuClicks = time.elapsed();
	cout << "Runtime:\t\t" << nuClicks << endl;
	ofs << "\tRuntime:\t" << nuClicks << endl << endl;
	*/
	
	/*
	time.reset();
	allele a("D8S1179", 11, 0.032, true);
	allele b("D8S1179", 12, 0.116, true);
	allele c("D8S1179", 13, 0.148, true);
	allele d("D8S1179", 14, 0.384, true);
	allele e("D8S1179", 15, 0.216, true);
	allele w("WILD", -1, 0.104, true);

	person s("Burke.44.D8.5", d, e);

	geno_f h(a, b, c, d, e, w, NULL_ALLELE);

	vector<allele> rep1;
	vector<allele> rep2;
	vector<allele> rep3;

	rep1.push_back(a);
	rep1.push_back(b);
	rep1.push_back(c);
	rep1.push_back(d);
	rep1.push_back(e);

	rep2.push_back(a);
	rep2.push_back(b);
	rep2.push_back(c);
	rep2.push_back(d);
	rep2.push_back(e);

	rep3.push_back(a);
	rep3.push_back(b);
	rep3.push_back(c);
	rep3.push_back(d);
	rep3.push_back(e);

	vector<allele> rep_stop1;
	rep_stop1.push_back(NULL_ALLELE);
	rep report2(3, s, h, rep1, rep2, rep3, rep_stop1);

	ofs << "\tSuspect:\t" << report2.get_suspect().get_name() << endl;
	ofs << "\tLotus:\t\t" << a.get_lotus() << endl;
	ofs << "\tLR:\t\t\t" << report2.get_LR() << endl;
	nuClicks = time.elapsed();
	cout << "Runtime:\t\t" << nuClicks << endl;
	ofs << "\tRuntime:\t" << nuClicks << endl << endl;
	*/
	
	
	time.reset();
	allele a("CSF1PO", 7, 0.056, true);
	allele b("CSF1PO", 9, 0.024, true);
	allele c("CSF1PO", 10, 0.292, true);
	allele d("CSF1PO", 11, 0.216, true);
	allele e("CSF1PO", 12, 0.288, true);
	allele w("WILD", -1, 0.124, true);

	person s("Burke.44.CSF.5", c, e);

	geno_f h(a, b, c, d, e, w, NULL_ALLELE);

	vector<allele> rep1;
	vector<allele> rep2;
	vector<allele> rep3;

	rep1.push_back(c);
	rep1.push_back(d);

	rep2.push_back(a);
	rep2.push_back(b);
	rep2.push_back(c);
	rep2.push_back(e);

	rep3.push_back(c);
	rep3.push_back(d);
	rep3.push_back(e);

	vector<allele> rep_stop1;
	rep_stop1.push_back(NULL_ALLELE);
	rep report2(3, s, h, rep1, rep2, rep3, rep_stop1);

	ofs << "\tSuspect:\t" << report2.get_suspect().get_name() << endl;
	ofs << "\tLotus:\t\t" << a.get_lotus() << endl;
	ofs << "\tLR:\t\t\t" << report2.get_LR() << endl;
	nuClicks = time.elapsed();
	cout << "Runtime:\t\t" << nuClicks << endl;
	ofs << "\tRuntime:\t" << nuClicks << endl << endl;
	

	/*
	time.reset();
	allele a("D16S539", 9, 0.196, true);
	allele b("D16S539", 10, 0.108, true);
	allele c("D16S539", 12, 0.22, true);
	allele d("D16S539", 13, 0.152, true);
	allele w("WILD", -1, 0.324, true);

	person s("Burke.44.D16.4", a, c);

	geno_f h(a, b, c, d, w, NULL_ALLELE);

	vector<allele> rep1;
	vector<allele> rep2;
	vector<allele> rep3;

	rep1.push_back(a);
	rep1.push_back(c);
	rep1.push_back(d);

	rep2.push_back(a);
	rep2.push_back(b);
	rep2.push_back(c);

	rep3.push_back(a);
	rep3.push_back(c);

	vector<allele> rep_stop1;
	rep_stop1.push_back(NULL_ALLELE);
	rep report2(3, s, h, rep1, rep2, rep3, rep_stop1);

	ofs << "\tSuspect:\t" << report2.get_suspect().get_name() << endl;
	ofs << "\tLotus:\t\t" << a.get_lotus() << endl;
	ofs << "\tLR:\t\t\t" << report2.get_LR() << endl;
	nuClicks = time.elapsed();
	cout << "Runtime:\t\t" << nuClicks << endl;
	ofs << "\tRuntime:\t" << nuClicks << endl << endl;
	*/


	ofs.close();
	
}